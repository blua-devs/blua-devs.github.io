{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is bLua?","text":"<p>bLua is a plugin for Unity that allows C# code to easily interact with native Lua 5.4 and vice versa. That means running blazing fast Lua code with just two lines of code.</p> <pre><code>bLuaInstance instance = new bLuaInstance();\ninstance.DoString(\"print('Hello world!')\");\n</code></pre> <p></p>"},{"location":"#what-makes-blua-special","title":"What makes bLua special?","text":"<p>bLua is lightweight and runs Lua code using native Lua 5.4, so your Lua code will run anywhere from 100 to 10,000 times faster than with plugins like Moonsharp and XLua! Try our benchmarks yourself in the bLua example Unity project.</p> <p>bLua was made with Unity development in mind, so there are no extra steps for getting Lua integrated into your Unity project. Simply clone the bLua repository into your <code>/Assets/Plugins/bLua</code> folder.</p> <p>bLua also runs on the latest version of Lua (Lua 5.4), which is faster and has more features than older versions of Lua.</p> <p></p> <p></p> <p>bLua is an open-source project being developed by Lua lovers. Contributors are listed on the website as a thanks for their work.</p> <p>If you have interest in contributing to the project, join our Discord server and inquire about becoming a contributor. Wanna help in other ways?</p> <ul> <li>Encourage others to check us out!</li> <li>Drop a star on our GitHub repository!</li> <li>Point out bugs and make feature requests in our Discord!</li> </ul> <p>  Tyster actively maintains and updates bLua. </p> <p>  Denivarius and the team at DMHub created the original native Lua interop that became bLua. </p> <p> World to Build uses bLua to power Lua scripts in over 2,500 user-created World to Build games. </p>"},{"location":"blog/","title":"Patch Notes","text":""},{"location":"blog/2023/03/18/initial-release/","title":"Initial Release","text":"<p>I've gone through and filled out the website with basic content and have officially dubbed the project as released! If you're eager to get your hands dirty and try it out, you're encouraged to do so. Don't hesitate to mention feature requests, bug reports, or requests for help.</p> <p>In other news, this is a great time for people who have shown interest in contributing to help out. If you or someone you know is versed in C# and Lua's C API, definitely reach out inquiring about contributing. We have an organized board of small and large feature requests and bugs that we call \"bounties\" that can easily be grabbed and worked on by individuals. A section on the website's landing page is dedicated to folks who contribute to the plugin.</p>"},{"location":"blog/2023/08/15/patch-1/","title":"Patch 1","text":"<ul> <li>C# Garbage Collection</li> <li>Improved logging</li> <li>Array/List/Dictionary support</li> <li>Params support</li> </ul> <p>Array, List&lt;&gt;, and Dictionary&lt;&gt;</p> <p>I just realized a few days ago that there was no support for C# functions that use types like Array, List&lt;&gt;, or Dictionary&lt;&gt; to be converted to and from Lua. That has now been added.</p> <p>CSharp Garbage Collection</p> <p>A very useful feature we were missing has just been added: C#-Managed Lua Garbage Collection! There are a few cases where userdata objects that are passed to userdata functions are never actually marked dead for Lua's internal garbage collection. Now the stragglers are collected and marked for Lua's GC every 10s or so. I might revisit this feature to add more control to when garbage collection happens, maybe even something more akin to Lua's built in GC.</p> <p>All of these changes were merged into the main repository in commit <code>136d00925ce076d968653d30b72d5a3ee837ebe7</code></p>"},{"location":"blog/2025/07/12/patch-2/","title":"Patch 2","text":"<ul> <li>Moved coroutine scheduler to C#</li> <li>Added support for async C# functions being called (and yielded) from Lua coroutines</li> <li>Added variable arg support for print and spawn helper funcs</li> <li>Massive cleanup pass</li> </ul> <p>Coroutines were being handled in a strange way mostly being managed by Lua code, which was causing some features to be difficult (namely async C# functions being called/yielded from Lua). Lua's C API doesn't allow you to mix and match whether C code or Lua is resuming and yielding coroutines, so it's either all Lua managed or all C# managed - bLua is now all C# managed!</p> <p>With the change to our management of coroutines, I was able to add support for async C# functions being called (and yielded) from Lua. Example of C# and Lua code working together seamlessly:</p> <pre><code>static Task&lt;string&gt; WaitDuration(float duration)\n{\n    Task.Delay(1000); // 1000ms = 1s\n    return \"Hello world!\";\n}\n\nfunction testCoroutine(duration)\n    local str = WaitDuration(duration)\n    print(str) // After 1 second, will print \"Hello world!\"\nend\nlocal co = coroutine.create(testCoroutine)\ncoroutine.resume(co)\n</code></pre> <p>Added variable args support for print and spawn, previously they were capped at 8 parameters.</p> <p>A massive cleanup pass also took place, which mostly consolidated similar code, removed unused code, and renamed commonly used developer-facing functions to better match the API of similar plugins and Unity standards. Some notable ones:</p> <ul> <li>(bLuaInstance) .ExecBuffer(...) -&gt; .LoadString(...)</li> <li>(bLuaValue) .CastToBool(...)/.Bool -&gt; .ToBool() (this goes for similarly named functions too)</li> <li>(Lua) spawn(...)/wait(...) -&gt; thread.spawn(...)/thread.wait(...)</li> </ul> <p>All of these changes were merged into the main repository in commit <code>d5f206c37203261b9dcb716f75cad7f0697db31a</code></p>"},{"location":"getting-started/csharp-calling-lua/","title":"C# Calling Lua","text":"<p>To access Lua from C#, we first need to define some Lua functions in code and run that code on our instance.</p> <pre><code>instance.DoString(@\"\n    function healCharacter(character)\n        local healthBefore = character.health\n        character.health = 100\n        print('Healed character from ', healthBefore, ' to ', character.health)\n    end\n\");\n</code></pre> <p>Now we need to get a reference to our <code>healCharacter</code> function in C#.</p> <pre><code>bLuaValue healFunction = instance.GetGlobal(\"healCharacter\");\n</code></pre> <p>Let's do some safety checks to make sure the function is valid, and then call it with a <code>Character</code> passed as a parameter.</p> <pre><code>if (healFunction != null &amp;&amp; healFunction.Type == DataType.Function)\n{\nCharacter newCharacter = new Character();\nnewCharacter.Damage(50);\ninstance.Call(healFunction, newCharacter);\n}\n</code></pre>"},{"location":"getting-started/example/","title":"Examples","text":""},{"location":"getting-started/example/#instance-component-example","title":"Instance Component Example","text":"<p>In the example below, an instance is created for this component with some settings that might be useful for game development. It's often desired to have Lua automatically resume coroutines every frame in game development so functions like <code>wait()</code> are guaranteed to resume when expected if they are called inside of a Lua coroutine.</p> <pre><code>using bLua;\nusing UnityEngine;\n\npublic class MyBLuaComponent : MonoBehaviour\n{\nprivate bLuaInstance instance;\n\nprivate void Awake()\n{\nbLuaSettings settings = new bLuaSettings()\n{\nfeatures = bLuaSettings.SANDBOX_ALL,\ntickBehavior = bLuaSettings.TickBehavior.Manual, coroutineBehaviour = bLuaSettings.CoroutineBehaviour.ResumeOnTick\n};\n\ninstance = new bLuaInstance(settings);\n\ninstance.OnPrint.AddListener(OnLuaPrint);\n}\n\nprivate void Start()\n{\ninstance?.DoString(@\"\n            print('Hello world!')\n        \");\n}\n\nprivate void Update()\n{\ninstance?.ManualTick();\n}\n\nprivate void OnLuaPrint(bLuaValue[] args)\n{\nstring log = \"\";\nforeach (bLuaValue arg in args)\n{\nlog += arg.ToString();\n}\nDebug.Log(log);\n}\n}\n</code></pre> <p></p>"},{"location":"getting-started/example/#global-instance-component-example","title":"Global Instance Component Example","text":"<p>Below is a more advanced example that makes use of only one instance throughout all usages of <code>MyBLuaComponent</code>. Note that this example also uses the <code>TickAtInterval</code> setting instead of <code>Manual</code>, so the instance will automatically tick itself at the interval in the settings, meaning there is no need to call <code>ManualTick</code> every frame. This does mean that Lua ticks will not necessarily line up with Unity's Update call, so modify the example if you'd like the instance to tick on Unity's Update.</p> <p>Another thing this example shows is how to keep code in separate \"environments\" (which are just Lua tables) so that code from one component doesn't interfere with code from another. You can also set up global functions and variables inside of the environment as shown below.</p> <pre><code>using bLua;\n\npublic static class MyGlobalBLua\n{\npublic static bLuaInstance instance;\n\nstatic MyGlobalBLua()\n{\nbLuaSettings settings = new bLuaSettings()\n{\nfeatures = bLuaSettings.SANDBOX_ALL,\ntickBehavior = bLuaSettings.TickBehavior.TickAtInterval,\ncoroutineBehaviour = bLuaSettings.CoroutineBehaviour.ResumeOnTick\n};\n\ninstance = new bLuaInstance(settings);\n\ninstance.OnPrint.AddListener(OnLuaPrint);\n}\n\nprivate static void OnLuaPrint(bLuaValue[] args)\n{\nstring log = \"\";\nforeach (bLuaValue arg in args)\n{\nlog += arg.ToString();\n}\nDebug.Log(log);\n}\n}\n</code></pre> <pre><code>using bLua;\nusing UnityEngine;\n\npublic class MyBLuaComponent : MonoBehaviour\n{\nprivate bLuaValue environment;\n\nprivate void Awake()\n{\nenvironment = bLuaValue.CreateTable(MyGlobalBLua.instance);\nenvironment.Set(\"Vector3\", new bLuaVector3Library()); // Vector3 helper function library\nenvironment.Set(\"GameObject\", new bLuaGameObjectLibrary()); // GameObject helper function library\nenvironment.Set(\"gameObject\", new bLuaGameObject(gameObject)); // This component's GameObject\n}\n\nprivate void Start()\n{\nMyGlobalBLua.instance?.DoString(@\"\n            print('Hello world!')\n        \",\nnull,\nenvironment);\n}\n}\n</code></pre>"},{"location":"getting-started/lua-calling-csharp/","title":"Lua Calling C#","text":"<p>To access C# userdata from Lua, you will need to create a class that has the bLuaUserData attribute. By default, instances will register all classes with this attribute when they initialize.</p> <pre><code>[bLuaUserData] // The bLua userdata attribute\npublic class Character\n{\npublic int health = 100;\n\npublic void Damage(int damage)\n{\nhealth -= damage;\n}\n}\n\n[bLuaUserData]\npublic class CharacterFunctionLibrary\n{\npublic static Character CreateCharacter()\n{\nreturn new Character();\n}\n}\n</code></pre> <p>Next, we can add an instance of this <code>Character</code> class to our Lua environment as a global variable. We can also add an instance of our <code>CharacterFunctionLibrary</code>.</p> <pre><code>instance.SetGlobal(\"character\", new Character());\ninstance.SetGlobal(\"CharacterFunctionLibrary\", new CharacterFunctionLibrary());\n</code></pre> <p>In our Lua code, we can access these userdata objects from anywhere since they are global.</p> <pre><code>instance.DoString(@\"\n    character:Damage(10)\n    print(character.health)\n\n    local newCharacter = CharacterFunctionLibrary.CreateCharacter()\n    newCharacter:Damage(20)\n    print(newCharacter.health)\n\");\n</code></pre>"},{"location":"getting-started/running-lua/","title":"Running Lua","text":"<p>To run Lua code with bLua, you will need to create a bLuaInstance. You can set up your instance with settings and rules to your liking through the settings property, or create an instance without any settings.</p> <pre><code>bLuaSettings settings = new bLuaSettings()\n{\nfeatures = bLuaSettings.SANDBOX_BASICMODDING,\ntickBehaviour = bLuaSettings.TickBehaviour.AlwaysTick\n};\n\n// Settings is an optional parameter\nbLuaInstance instance = new bLuaInstance(settings);\n</code></pre> <p>You only need one instance to run Lua code, it can be reused by multiple chunks of code as desired. You can run standard Lua code through the instance by passing it in as a string.</p> <pre><code>instance.DoString(@\"\n    local myInteger = 100\n    myInteger = 50\n    print(myInteger)\n\");\n</code></pre> <p>You will notice that the <code>print</code> function in Lua doesn't automatically send logs to Unity's editor log. You can hook this up yourself through an event on the instance.</p> <pre><code>instance.OnPrint.AddListener(LuaPrint);\n\nvoid LuaPrint(bLuaValue[] parameters)\n{\nstring log = \"\";\nforeach (bLuaValue parameter in parameters)\n{\nlog += parameter.ToString();\n}\nDebug.Log(log); // Log the print to Unity's log\n}\n</code></pre>"},{"location":"getting-started/unity-setup/","title":"Unity Setup","text":"<p>bLua was built with Unity usage in mind, so setting up your Unity project with bLua is straightforward.</p> <ol> <li>Download the contents of the bLua repository.</li> <li>Create a folder in your Unity project under <code>/Assets/Plugins/bLua</code>.</li> <li>Put the files you downloaded into this new folder.</li> </ol> <p>That's it! Continue to the next section to start running Lua code, or review possible issues and their solutions below.</p> <p></p>"},{"location":"getting-started/unity-setup/#possible-issues","title":"Possible Issues","text":""},{"location":"getting-started/unity-setup/#error-cs0227-unsafe-code-may-only-appear-in-compiling-with-unsafe","title":"error CS0227: Unsafe code may only appear in compiling with /unsafe.","text":"<p>bLua uses unsafe code for some features. You can enable \"Allow 'unsafe' code\" in Unity's Player Settings to fix this error.</p> <p></p>"},{"location":"getting-started/unity-setup/#troubleshooting","title":"Troubleshooting","text":"<p>If you're having trouble setting up bLua in your Unity project, feel free to ask for further assistance in the bLua Discord server.</p>"},{"location":"reference/instance/","title":"bLuaInstance","text":"<p>A bLuaInstance (also referred to as \"instance\") is the object responsible for communicating with Lua from C#. An instance has its own settings, features, and access to your C# code that are set during the creation of the instance. You only need one instance in many cases, but if you want to, you can have separate instances that each have their own settings, features, and/or C# access.</p> <p></p>"},{"location":"reference/instance/#methods","title":"Methods","text":""},{"location":"reference/instance/#dostring","title":"DoString","text":"<p>Loads the given string as a Lua chunk and runs it.</p>"},{"location":"reference/instance/#loadstring","title":"LoadString","text":"<p>Loads the given string as a Lua chunk. This function only loads the chunk; it does not run it.</p>"},{"location":"reference/instance/#getglobal","title":"GetGlobal","text":"<p>Returns a global value on the Lua instance.</p>"},{"location":"reference/instance/#setglobal","title":"SetGlobal","text":"<p>Sets a global value on the Lua instance.</p>"},{"location":"reference/instance/#call","title":"Call","text":"<p>Calls a Lua function that is passed in as a bLuaValue. You can also pass in arguments for the Lua function in this function. Returns the result of the Lua function, if it has one.</p>"},{"location":"reference/instance/#callascoroutine","title":"CallAsCoroutine","text":"<p>Creates a coroutine for the function that is passed in as a bLuaValue, then runs the coroutine. You can also pass in arguments for the coroutine in this function. Returns the coroutine that has been run.</p> <p>If the <code>Features.Coroutines</code> feature is not enabled, this function will use <code>Call</code> instead.</p>"},{"location":"reference/instance/#createcoroutine","title":"CreateCoroutine","text":"<p>Creates a coroutine for the function that is passed in as a bLuaValue. Returns the coroutine that has been created.</p>"},{"location":"reference/instance/#resumecoroutine","title":"ResumeCoroutine","text":"<p>Resumes a coroutine that is passed in as a bLuaValue. You can also pass in arguments for the coroutine in this function. Returns true if the resume succeeded, and false if something went wrong.</p>"},{"location":"reference/instance/#manualtick","title":"ManualTick","text":"<p>Manually ticks this instance. This function calls the same code as the internal tick systems would. You should call this when your instance's <code>TickBehavior</code> is set to <code>Manual</code>, since there is no automatic ticking when using that setting.</p>"},{"location":"reference/instance/#manualcollectgarbage","title":"ManualCollectGarbage","text":"<p>Manually collect garbage on this instance. This function calls the same code as the internal C# garbage collection system would.</p>"},{"location":"reference/instance/#getisfeatureenabled","title":"GetIsFeatureEnabled","text":"<p>Returns true if the given <code>Feature</code> flag is enabled on this instance.</p> <p></p>"},{"location":"reference/instance/#unityevents","title":"UnityEvents","text":""},{"location":"reference/instance/#onprint","title":"OnPrint","text":"<p>This event passes an array of bLuaValues, which represent the objects or strings passed into a <code>print()</code> from Lua. This event will only fire if <code>Features.CSharpPrintOverride</code> is enabled.</p>"},{"location":"reference/instance/#onerror","title":"OnError","text":"<p>This event passes two strings, the first of which is the error message, and the second of which is the Lua stack trace (if one is available). This event will fire for both Lua errors and bLua errors relevant to Lua code.</p>"},{"location":"reference/instance/#ontick","title":"OnTick","text":"<p>This event fires whenever the instance ticks.</p>"},{"location":"reference/userdata/","title":"bLuaUserData","text":"<p>bLuaUserData is a static class that has helper functions related to registering and creating userdata in Lua from C# objects.</p> <p>The only way Lua can access C# code from Lua code is if the C# code is first registered as userdata (a Lua concept). The way bLua allows you to register userdata is by marking C# classes with the <code>bLuaUserDataAttribute</code>, like the example below.</p> <pre><code>[bLuaUserData]\npublic class MyUserData\n{\npublic int numberProperty;\n\npublic void LogSomething(string text)\n{\nDebug.Log(text)\n}\n}\n</code></pre> <p>More examples of userdata and how to access it on the \"Getting Started\" page.</p> <p>bLuaInstances will automatically register all C# classes marked as userdata by default. If you want to register specific types manually or at a later time than the instance's creation, you can use the <code>AutoRegisterTypes</code> setting and manually call <code>Register</code> or <code>RegisterAllBLuaUserData</code>.</p> <p></p>"},{"location":"reference/userdata/#static-methods","title":"Static Methods","text":""},{"location":"reference/userdata/#register","title":"Register","text":"<p>Registers a given type on the given bLuaInstance.</p>"},{"location":"reference/userdata/#registerallbluauserdata","title":"RegisterAllBLuaUserData","text":"<p>Registers all types in the project that are marked with the <code>bLuaUserDataAttribute</code> on the given bLuaInstance. This is run automatically on bLuaInstances by default when they are created.</p>"},{"location":"reference/userdata/#isuserdata","title":"IsUserData","text":"<p>Returns true if the given type is marked with the <code>bLuaUserDataAttribute</code>,  which allows it to be registered as userdata.</p>"},{"location":"reference/userdata/#isuserdataregistered","title":"IsUserDataRegistered","text":"<p>Returns true if the given type is registered on the given bLuaInstance.</p> <p></p>"},{"location":"reference/userdata/#attributes","title":"Attributes","text":""},{"location":"reference/userdata/#bluauserdata_1","title":"bLuaUserData","text":"<p>This attribute goes on classes and allows the type to be registered as userdata on a bLuaInstance.</p>"},{"location":"reference/userdata/#bluahidden","title":"bLuaHidden","text":"<p>This attribute goes on methods, properties, and fields, and will hide them from being accessible in Lua as userdata. For example, if you have a class <code>Character</code> that is marked as userdata with <code>[bLuaUserData]</code>, and a method on that class <code>Debug_TakeDamage</code> that is marked with <code>[bLuaHidden]</code>, the <code>Debug_TakeDamage</code> method will not be accessible from Lua.</p>"},{"location":"reference/userdata/#bluaparam_ignored","title":"bLuaParam_Ignored","text":"<p>This attribute goes on parameters in methods, and will cause the parameter to be ignored when registering the method as userdata. For example, if you have a method on a userdata class with two parameters, the first marked with <code>[bLuaParam_Ignored]</code>, and the second without that attribute, Lua can call that function as if only the second parameter existed. On the C# side, the first parameter will never be filled with data from Lua but could still be called from C# with that parameter filled.</p>"},{"location":"reference/userdata/#bluaparam_state","title":"bLuaParam_State","text":"<p>This attribute goes on parameters in methods of type <code>IntPtr</code>. This attribute does all of the same things as <code>[bLuaParam_Ignored]</code> but will automatically fill the parameter with the calling Lua state of the Lua thread that called the userdata method. This is mostly used for internal bLua features.</p>"},{"location":"reference/value/","title":"bLuaValue","text":"<p>A bLuaValue (also referred to as \"value\") is an object representing some value in Lua. It can be many types, some of which aren't directly translated into C# such as threads and tables, and can also be a reference ID pointing to a C# object. Values exist within a specific bLuaInstance, and wont work if used on other instances.</p> <p></p>"},{"location":"reference/value/#properties","title":"Properties","text":""},{"location":"reference/value/#luatype","title":"luaType","text":"<p>Returns the <code>LuaType</code> of this value.</p> <p></p>"},{"location":"reference/value/#methods","title":"Methods","text":""},{"location":"reference/value/#isnil","title":"IsNil","text":"<p>Returns true if this value is <code>nil</code>.</p>"},{"location":"reference/value/#toboolnumberintfloatstringlistdictionary","title":"To(Bool/Number/Int/Float/String/List/Dictionary)","text":"<p>Attempts to convert the value to a C# type based on the specific function called (<code>ToBool</code>, <code>ToNumber</code>, etc). If the conversion can't be done, the default value of that type will be returned. You can check the <code>LuaType</code> of this value before calling this function by checking the <code>luaType</code> property first.</p>"},{"location":"reference/value/#topointer","title":"ToPointer","text":"<p>Attempts to convert the value to an <code>IntPtr</code> \"pointer\". If the conversion can't be done, the default value of <code>IntPtr</code> will be returned. This function is typically used for Lua types that don't have a C# representation, such as threads and tables, in which case the \"pointer\" points to the object in Lua.</p>"},{"location":"reference/value/#toobject","title":"ToObject","text":"<p>Attempts to convert the value to an <code>object</code>. If the conversion can't be done, null will be returned. This function is typically used for C# types that don't have a Lua representation, such as userdata.</p>"},{"location":"reference/value/#touserdata","title":"ToUserData","text":"<p>Attempts to convert the value to the given type <code>&lt;T&gt;</code>. If the conversion can't be done, null will be returned. This function is typically used for C# types that don't have a Lua representation.</p>"},{"location":"reference/value/#isuserdatatype","title":"IsUserDataType","text":"<p>Returns true if this value represents userdata with the given type <code>&lt;T&gt;</code>.</p> <p></p>"},{"location":"reference/value/#static-methods","title":"Static Methods","text":""},{"location":"reference/value/#createnil","title":"CreateNil","text":"<p>Returns a value that represents <code>nil</code>.</p>"},{"location":"reference/value/#createboolnumberstring","title":"Create(Bool/Number/String)","text":"<p>Returns a new value that represents the given value based on the specific function called (<code>CreateBool</code>, <code>CreateNumber</code>, etc).</p>"},{"location":"reference/value/#createuserdata","title":"CreateUserData","text":"<p>Returns a new value that represents the given [userdata supported] C# object.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2023/","title":"2023","text":""}]}